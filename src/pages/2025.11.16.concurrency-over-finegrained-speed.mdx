export const preload = async ({ id, origin }) => {
  const { views, date } = await fetch(`${origin}/api/views/${id}`).then(
    response => response.json()
  );
  return {
    layout: {
      views,
      date,
      title: '왜 시그널 기반 Fine-grained보다 Concurrent Mode가 더 매력적인가',
      description:
        'Concurrent Mode와 시그널 기반 Fine-grained 기법을 둘 다 직접 구현해보고 싶은데, 둘 다 너무 흥미로워서 무엇을 먼저 만들지 도무지 결정을 못 하고 있는 것입니다.',
      openGraph: {
        title: '왜 시그널 기반 Fine-grained보다 Concurrent Mode가 더 매력적인가',
        description:
          'Concurrent Mode와 시그널 기반 Fine-grained 기법을 둘 다 직접 구현해보고 싶은데, 둘 다 너무 흥미로워서 무엇을 먼저 만들지 도무지 결정을 못 하고 있는 것입니다.',
        images: [
          {
            url: '/assets/posts/concurrency-over-finegrained-speed.png',
            width: 1024,
            height: 1024,
          },
        ],
      },
    },
  };
};


<img
  src="/assets/posts/concurrency-over-finegrained-speed.png"
  style={{ height: '300px', width: '100%', objectFit: 'cover' }}
/>

## 개요

UI 라이브러리를 만드는 게 제 취미인데요, 요즘 정말 즐거운 고민이 하나 생겼습니다.

Concurrent Mode와 시그널 기반 Fine-grained 기법을 둘 다 직접 구현해보고 싶은데, 둘 다 너무 흥미로워서 무엇을 먼저 만들지 도무지 결정을 못 하고 있는 것입니다.

저는 관심있는 기술이나 구조를 보면 원리를 파악하고 직접 구현해보는 과정에서 일종의 “정복했다!”라는 성취감을 느끼는 타입입니다. 마치 게임에서 어려운 보스를 클리어할 때 느끼는 짜릿함과 비슷하달까요.

최근 웹 서핑을 하다 보니 VDOM을 다소 과하게 깎아내리면서 Fine-grained 기법의 속도를 띄우는 글들을 자주 접했고, 그러다 문득 이런 생각이 들었습니다.

> 정말 Fine-grained의 빠름이 가장 중요한 가치일까? 왜 나는 오히려 Concurrent Mode가 더 매력적으로 느껴질까?

물론 이 둘은 직접 비교할 만한 대상은 아니지만, 재미 삼아 이번 글에서는 **제가 왜 Fine-grained의 속도보다 Concurrent Mode의 가치가 더 크다고 생각하게 되었는지** 제 나름의 논리를 정리해보려고 합니다.

## 속도가 전부는 아니다

UI 라이브러리에서 속도는 물론 중요한 가치입니다. 그러나 이미 현대 프레임워크들은 대부분 “충분히 빠른” 상태에 도달해 있습니다.

Fine-grained 방식이 몇 ms 더 빠를 수는 있지만, **대부분의 일반적인 웹 애플리케이션**에서 그 미세한 차이는 실제 사용자 경험에 큰 영향을 주지 않을 수 있습니다.

물론 고성능 차트, 데이터 그리드, 혹은 그래픽 에디터처럼 DOM 조작이 극한으로 빈번하고 미세한 지연도 치명적인 특정 도메인에서는 이 '몇 ms'의 차이가 결정적일 수 있습니다. 하지만 사람들이 일상적인 웹 UI가 “느리다”고 느끼는 근본적인 이유는 대부분 미세한 연산 성능 때문이 아니라 전혀 다른 곳에서 발생합니다.

만약 속도만이 절대적인 가치였다면, 우리는 지금도 C나 기계어로 UI를 개발하고 있을 것입니다. 하지만 현실은 그렇지 않습니다. 우리는 map이나 filter 같은 편리한 추상화를 쓰고, 상위 수준의 언어와 구조를 선택합니다.

정말 속도만 중요했다면, 우리는 지금도 모든 코드를 for문으로만 짜고 있을 겁니다. 하지만 그러지 않죠. 왜냐하면 개발자가 이해하기 쉽고, 읽기 편하고, 유지 보수하기 좋은 구조가 장기적으로 성능 최적화 이상의 가치를 만들기 때문입니다.

## 느린 이유는 VDOM 때문이 아니다

종종 "VDOM은 느리다", "대규모 앱에서 VDOM은 병목이다" 같은 말이 들립니다. 하지만 실제 웹 성능 병목의 90% 이상은 VDOM diff 때문이 아닙니다.

실제 느린 원인들은 Layout/Reflow 비용, 무거운 리소스, 네트워크 지연, 과도한 DOM 조작, 메인 스레드를 독점하는 무거운 JS 실행입니다. 즉, 대부분의 사용자가 느끼는 "버벅임"은 VDOM diff 때문이 아니라 브라우저 렌더링 파이프라인과 메인 스레드 블로킹 때문입니다.

## Fine-grained의 극한 속도 보다는, Concurrent Mode의 작업 관리 능력

가상돔이 diff를 계산하며 트리를 따라 내려가는 오버헤드는 실제로 존재합니다. 하지만 현실적인 규모의 UI에서는 이 비용이 치명적이지 않습니다.

Fine-grained도 규모가 커지면 똑같은 문제에 부딪힙니다. state 변화가 여러 방향으로 퍼지고, effect가 동시에 여러 개 실행되며, 콜스택에 작업이 한꺼번에 쌓입니다.

이때 진짜 중요한 것은 단순한 "업데이트 속도"가 아닙니다. 작업을 적절히 쪼개고, 우선순위를 조정하고, 긴 작업을 중단하거나 재개하며, 사용자 입력을 먼저 처리하게 만드는 **"작업 관리 능력"** 입니다.

물론 시그널 기반 라이브러리들도 batch 같은 기능으로 여러 업데이트를 묶어 처리하려 합니다. 하지만 이것은 '횟수를 줄이는 것'에 가깝습니다. 실행될 때는 여전히 동기적으로, 즉시, 끝까지 실행됩니다.

Concurrent Mode는 다릅니다. Time Slicing으로 긴 렌더링을 5ms 단위로 쪼개고, 우선순위 스케줄링으로 급한 작업을 먼저 처리하며, 높은 우선순위 작업이 들어오면 현재 작업을 중단하고 나중에 재개할 수 있습니다.

앱이 커지면 100개의 signal과 effect가 연결된 상황이 옵니다. 하나의 signal이 변경되면 연쇄적으로 100개의 effect가 즉시 실행됩니다. 이 과정이 끝날 때까지 사용자가 스크롤하려 해도, 타이핑하려 해도 기다려야 합니다.

Fine-grained의 "즉시 실행"은 작은 규모에서는 장점이지만, 규모가 커질수록 제약이 됩니다. 반면 Concurrent Mode의 "제어 가능한 실행"은 처음에는 복잡해 보이지만, 규모가 커질수록 필수가 됩니다.

## VDOM의 선언적 렌더링과 단방향 흐름이 주는 예측 가능성

VDOM(Virtual DOM) 기반 구조가 예측하기 쉬운 이유는 **‘선언적 단방향 렌더링 파이프라인’** 을 따르기 때문입니다.

모든 UI 업데이트는 상태 변경 → render → VDOM → DOM 이라는 한 방향의 일관된 흐름을 거칩니다.

개발자는 이 단일 파이프라인만 알고 있으면 되기 때문에, “어디서 어떤 업데이트가 일어나는지”를 비교적 안정적으로 추론할 수 있습니다. 규모가 커져도 이 흐름 자체는 바뀌지 않습니다.

반면 시그널(Signal) 기반 Fine-grained 방식에서는 상태와 UI가 자동으로 연결되며 **‘의존성 그래프’** 가 형성됩니다. 처음에는 단순해 보이지만, 앱의 복잡도가 일정 수준을 넘어서면 이 그래프는 거미줄처럼 한꺼번에 퍼지기 시작합니다.

이 지점부터는 “이 상태가 어디까지 영향을 미치는지”, “왜 지금 이 UI가 갱신되었는지” 를 이해하기 위해 그래프 전체를 되짚어야 하는 순간이 갑작스럽게 찾아옵니다.

즉, Fine-grained의 복잡성은 선형적으로 증가하지 않습니다. 규모가 커질수록 어느 순간부터 그래프 전체가 한 번에 머릿속으로 뛰어들어오는 듯한 급격한 인지 부하가 발생합니다.

물론 VDOM(React)에서도 memo, useCallback 같은 최적화 과정에서 인지적 부담이 존재합니다. 하지만 이 경우의 복잡성은 어디까지나 **이미 알고 있는 단일 파이프라인을 ‘얼마나 덜 실행할 것인가’**에 대한 명시적인 조절의 문제입니다. 흐름 자체는 변하지 않습니다.

반면 Fine-grained의 복잡성은 자동으로 얽혀가는 ‘의존성 네트워크 자체’를 상황에 따라 직접 추적해야 하는 문제이며, 이 네트워크는 규모가 커질수록 갑작스럽게 복잡도가 폭증하는 특성을 가집니다.

결론적으로, 앱이 커질수록 복잡하게 확장된 의존성 그래프 전체를 머릿속에 넣고 추적하는 것보다, 변하지 않는 단일 렌더링 파이프라인 하나를 기준으로 사고하는 방식이 훨씬 안정적이며 인지적으로 수월합니다.

## 결론

제가 Concurrent Mode를 먼저 구현하고 싶은 이유는 단순합니다.

Fine-grained의 세밀함을 이용한 속도 최적화도 충분히 매력적이지만, 앱 전체의 부드러움과 안정성, 그리고 예측 가능성을 지키는 데에는 Concurrent Mode가 제공하는 작업 관리 능력이 훨씬 더 본질적이라고 느꼈기 때문입니다.
이 방식이 장기적으로 복잡함을 줄이고, 시스템을 더 안정적이고 제어 가능한 방향으로 이끈다고 생각합니다.

물론 이것이 “Fine-grained가 좋지 않다”는 의미는 아닙니다. 작은 규모의 앱이나 단순한 인터랙션, 혹은 실시간성이 중요한 상황에서는 Fine-grained의 즉각적인 반응성이 오히려 더 적합한 선택이 될 수 있습니다.

다만 좀 더 복잡한 웹 페이지에서는, 수많은 데이터와 실시간 스트림을 처리하고 여러 팀이 함께 장기간 유지보수해야 하는 환경을 고려해 보면, 순수한 실행 속도보다 업데이트를 어떻게 관리할 수 있는가가 더 중요한 가치가 되는 것 같습니다.

저 역시 Fine-grained 방식이 지닌 즉각성과 단순함을 좋아합니다. 다만 최근에는 “Fine-grained이면 항상 더 빠르고 더 낫다”는 식의 단정적인 인식도 종종 보이기에, 이번 글에서는 의도적으로 반대편 관점에서 제 생각을 정리해 보았습니다.

읽어주셔서 감사합니다. 가벼운 마음으로 재미있게 봐주셨으면 합니다.
