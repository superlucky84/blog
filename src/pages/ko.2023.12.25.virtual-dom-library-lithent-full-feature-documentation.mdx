export const preload = async ({ id, origin }) => {
  const { views, date } = await fetch(`${origin}/api/views/${id}`).then(
    response => response.json()
  );
  return {
    layout: {
      views,
      date,
      title: '가상돔 라이브러리 Lithent 전체 기능 설명서',
      description:
        'Lithent는 JSX를 기반으로 만들어진 경량 가상돔 UI 라이브러리입니다.',
      openGraph: {
        title: '가상돔 라이브러리 Lithent 전체 기능 설명서',
        description:
          'Lithent는 JSX를 기반으로 만들어진 경량 가상돔 UI 라이브러리입니다.',
        images: [
          {
            url: '/assets/posts/virtual-dom-library-lithent.png',
            width: 1080,
            height: 1080,
          },
        ],
      },
    },
  };
};

<img
  src="/assets/posts/virtual-dom-library-lithent.png"
  style={{ height: '300px', width: '100%', objectFit: 'cover' }}
/>


[Github](https://github.com/superlucky84/lithent) | [Homepage](https://superlucky84.github.io/lithent/)

## 소개

Lithent는 경량(gzip 4KB)이면서도 예측 가능한 UI를 만들 수 있는 JavaScript 가상돔 라이브러리입니다.

클로저 기반의 명확한 상태 관리와 선택적 확장 기능을 통해, 작은 프로젝트부터 본격적인 SPA까지 유연하게 대응합니다. 빌드 툴 없이 CDN으로 바로 사용할 수도 있고, Vite와 함께 JSX를 사용하는 현대적인 개발 환경에서도 사용할 수 있습니다.

**핵심 철학:**
- **4KB 코어**: 필수 기능만 담은 경량 코어
- **클로저 기반 상태**: 복잡한 API 없이 순수 JavaScript 클로저로 상태 관리
- **수동/반응형 선택**: `renew()` 수동 제어 또는 `lstate` 자동 반응형
- **점진적 도입**: 정적 HTML에서 풀 SPA까지

## 목차

### 1. 기본 기능
- mount / lmount - 컴포넌트 생성
- updater - 렌더 함수
- renew - 수동 업데이트
- render - DOM 마운트
- Lifecycle Hooks - mountCallback, updateCallback, mountReadyCallback
- portal - DOM 위치 제어
- props & children - 컴포넌트 통신
- ref - DOM 직접 접근
- innerHTML - Raw HTML 삽입
- stateless components - 상태 없는 컴포넌트
- nextTick - DOM 업데이트 대기

### 2. 확장 기능 (Helper)
- state / lstate - 반응형 상태
- store / lstore - 전역 상태
- context / lcontext - 컨텍스트 공유
- computed - 계산된 값
- effect - 부수 효과
- cacheUpdate - 메모이제이션

### 3. 템플릿 옵션
- JSX - Vite 플러그인
- HTM Tags - Tagged template literals
- FTags - 함수형 태그
- Template Strings - 실험적 템플릿

### 4. SSR
- Server-Side Rendering - renderToString, hydration

---

## 기본 기능

Lithent는 가상돔을 사용하는데 꼭 필요한 최소한의 기본 기능을 제공합니다. 기본 기능만으로도 충분히 실용적인 UI를 만들 수 있습니다.

### mount / lmount

**mount**는 컴포넌트를 생성하는 함수입니다. 클로저를 이용해 상태와 기능을 정의하고, JSX를 반환하는 업데이터 함수를 리턴합니다.

**수동 모드 (mount):**
```tsx
import { mount } from 'lithent';

const Counter = mount((renew, props) => {
  let count = 0;

  const increase = () => {
    count++;
    renew(); // 수동으로 업데이트 트리거
  };

  return () => <button onClick={increase}>count: {count}</button>;
});
```

**자동 반응형 모드 (lmount):**
```tsx
import { lmount } from 'lithent';
import { lstate } from 'lithent/helper';

const Counter = lmount((props) => {
  const count = lstate(0);

  const increase = () => {
    count.value++; // 자동으로 업데이트
  };

  return () => <button onClick={increase}>count: {count.value}</button>;
});
```

**마운터 함수의 인자:**
- 첫 번째 인자: `renew` - 컴포넌트 업데이트 함수 (lmount에서는 생략 가능)
- 두 번째 인자: `props` - 부모로부터 받은 속성
- 세 번째 인자: `children` - 자식 요소들

마운터는 컴포넌트가 처음 생성될 때 **단 한 번만** 실행됩니다. 이곳에서 정의한 변수와 함수는 클로저로 보존되어 업데이터에서 계속 사용할 수 있습니다.

### updater

마운터가 리턴하는 함수를 **업데이터**라고 합니다. 업데이터는 JSX를 리턴하며, 컴포넌트가 업데이트될 때마다 실행됩니다.

```tsx
const Component = mount((renew, props) => {
  let count = 0;
  const increase = () => { count++; renew(); };

  // 이 함수가 업데이터입니다
  return (props) => (
    <button onClick={increase}>
      count: {count}, prop: {props.value}
    </button>
  );
});
```

업데이터는 선택적으로 `props`를 인자로 받을 수 있습니다. 마운터의 props를 클로저로 참조할 수도 있지만, 업데이트 시점의 최신 props를 보장받으려면 업데이터의 인자를 사용하는 것이 안전합니다.

### renew

`renew` 함수는 컴포넌트를 수동으로 업데이트합니다. 마운터의 첫 번째 인자로 제공되며, 호출 시 업데이터가 재실행되어 UI가 갱신됩니다.

```tsx
const Component = mount(renew => {
  let items = ['a', 'b'];

  const addItem = () => {
    items.push('c');
    renew(); // UI 업데이트 트리거
  };

  return () => (
    <div>
      <ul>{items.map(item => <li>{item}</li>)}</ul>
      <button onClick={addItem}>Add</button>
    </div>
  );
});
```

`renew()`는 불필요한 자동화를 제거하여 업데이트 시점을 명확하게 제어할 수 있게 해줍니다. Helper의 `state`, `lstate`를 사용하면 `renew()` 호출을 자동화할 수 있습니다.

### render

`render` 함수는 가상돔을 실제 DOM에 연결합니다.

```tsx
import { h, render, mount } from 'lithent';

const App = mount(renew => {
  let count = 0;
  return () => <div>Count: {count}</div>;
});

// 기본 사용: appendChild
render(<App />, document.getElementById('root'));

// insertBefore 사용
render(
  <App />,
  document.getElementById('root'),
  document.querySelector('.insert-before-me')
);
```

`render` 함수는 `destroy` 함수를 리턴합니다. `destroy()`를 호출하면 해당 컴포넌트가 언마운트됩니다.

```tsx
const destroy = render(<App />, document.getElementById('root'));

// 나중에 제거
destroy();
```

### Lifecycle Hooks

컴포넌트의 생명주기 시점에 특정 로직을 실행할 수 있습니다.

**mountCallback:**
컴포넌트가 DOM에 마운트된 직후 실행됩니다.

```tsx
import { mount, mountCallback } from 'lithent';

const Component = mount(() => {
  mountCallback(() => {
    console.log('mounted');

    // 언마운트 시 실행될 클린업 함수
    return () => {
      console.log('unmounted');
    };
  });

  return () => <div>Component</div>;
});
```

**updateCallback:**
컴포넌트가 업데이트되기 전과 후에 실행됩니다.

```tsx
import { mount, updateCallback } from 'lithent';

const Component = mount((renew, props) => {
  updateCallback(
    () => {
      console.log('before update');
      return () => console.log('after update');
    },
    () => [props.count] // 의존성: count가 변경될 때만 실행
  );

  return ({ count }) => <div>count: {count}</div>;
});
```

**mountReadyCallback:**
가상돔이 준비되었을 때, 실제 DOM에 마운트되기 전에 실행됩니다. `mountCallback`보다 빠르게 실행됩니다.

```tsx
import { mount, mountReadyCallback } from 'lithent';

const Component = mount(() => {
  mountReadyCallback(() => {
    console.log('virtual dom ready, before actual mount');

    return () => {
      console.log('cleanup before unmount');
    };
  });

  return () => <div>Component</div>;
});
```

**실행 순서:** mountReadyCallback → 실제 DOM 마운트 → mountCallback

### portal

포탈은 자식 요소를 DOM의 다른 위치에 렌더링합니다.

```tsx
import { mount, portal, Fragment } from 'lithent';

const Modal = mount(renew => {
  let count = 0;
  const increase = () => { count++; renew(); };

  return () => (
    <Fragment>
      <button onClick={increase}>Update</button>
      {portal(
        <div class="modal">Count: {count}</div>,
        document.getElementById('modal-root')
      )}
    </Fragment>
  );
});
```

포탈은 모달, 툴팁, 드롭다운 등 부모 DOM 계층 구조를 벗어나야 하는 UI에 유용합니다.

### props & children

컴포넌트는 props와 children을 통해 데이터를 전달받습니다.

```tsx
const Child = mount((renew, props, children) => {
  return () => (
    <div>
      <h1>{props.title}</h1>
      <div>{children}</div>
    </div>
  );
});

const Parent = mount(() => {
  return () => (
    <Child title="Hello">
      <p>This is children content</p>
    </Child>
  );
});
```

props는 마운터와 업데이터 모두에서 접근 가능하며, children은 마운터의 세 번째 인자로 제공됩니다.

### ref

`ref`를 사용하면 DOM 요소에 직접 접근할 수 있습니다.

```tsx
import { mount, ref } from 'lithent';

const Component = mount(() => {
  const inputRef = ref<HTMLInputElement>();

  const focus = () => {
    inputRef.value?.focus();
  };

  return () => (
    <div>
      <input ref={inputRef} type="text" />
      <button onClick={focus}>Focus Input</button>
    </div>
  );
});
```

ref는 컴포넌트가 마운트된 후에만 `.value` 값이 설정됩니다.

### innerHTML

`innerHTML` 속성을 사용하면 Raw HTML을 안전하게 삽입할 수 있습니다.

```tsx
const Component = mount(() => {
  const htmlContent = '<strong>Bold</strong> and <em>italic</em> text';

  return () => <div innerHTML={htmlContent} />;
});
```

**주의:** XSS 공격을 방지하기 위해 사용자 입력을 innerHTML에 직접 사용하지 마세요.

### stateless components

상태가 필요 없는 컴포넌트는 `mount` 없이 순수 함수로 작성할 수 있습니다.

```tsx
// Stateless 컴포넌트
const Greeting = ({ name }, children) => (
  <div>
    <h1>Hello, {name}!</h1>
    {children}
  </div>
);

// 사용
const App = mount(() => {
  return () => (
    <Greeting name="World">
      <p>Welcome to Lithent</p>
    </Greeting>
  );
});
```

Stateless 컴포넌트는 props와 children만 받으며, 재사용 가능한 UI 조각을 만드는 데 적합합니다.

### nextTick

`nextTick`은 다음 DOM 업데이트가 완료될 때까지 기다립니다.

```tsx
import { mount, nextTick } from 'lithent';

const Component = mount(renew => {
  let count = 0;

  const increase = async () => {
    count++;
    renew();

    await nextTick();
    // 이 시점에서 DOM이 업데이트 완료됨
    console.log('DOM updated');
  };

  return () => <button onClick={increase}>count: {count}</button>;
});
```

nextTick은 내부적으로 `queueMicrotask`를 사용하여 모든 리렌더링 요청이 처리된 후 실행됩니다.

---

## 확장 기능 (Helper)

Helper는 기본 기능을 활용하여 더 편리하게 사용할 수 있도록 만든 선택적 확장 기능입니다. 필요한 Helper만 import하여 사용할 수 있습니다.

모든 Helper의 구현 코드는 [GitHub 저장소](https://github.com/superlucky84/lithent/tree/master/helper/src/hook)에서 확인할 수 있습니다.

### state / lstate

`state` Helper는 값 변경 시 자동으로 `renew()`를 호출하는 반응형 상태를 만듭니다.

**수동 모드 (state):**
```tsx
import { mount } from 'lithent';
import { state } from 'lithent/helper';

const Counter = mount(renew => {
  const count = state(0, renew);

  const increase = () => {
    count.value++; // renew()가 자동으로 호출됨
  };

  return () => <button onClick={increase}>count: {count.value}</button>;
});
```

**자동 모드 (lstate):**
```tsx
import { lmount } from 'lithent';
import { lstate } from 'lithent/helper';

const Counter = lmount(() => {
  const count = lstate(0); // renew 인자 불필요

  return () => <button onClick={() => count.value++}>count: {count.value}</button>;
});
```

state는 간단한 getter/setter 패턴으로 구현되어 있습니다:

```tsx
export const state = <T>(value: T, renew: () => boolean) => {
  let result = value;

  return {
    get value() { return result; },
    set value(newValue: T) {
      result = newValue;
      renew();
    }
  };
};
```

### store / lstore

`store`는 여러 컴포넌트가 공유하는 전역 상태를 관리합니다.

```tsx
import { mount } from 'lithent';
import { store } from 'lithent/helper';

// Store 생성
const useSharedStore = store({
  text: 'shared text',
  count: 0
});

const Component1 = mount(renew => {
  const sharedStore = useSharedStore(renew);

  const changeText = (e) => {
    sharedStore.text = e.target.value;
  };

  return () => <input value={sharedStore.text} onInput={changeText} />;
});

const Component2 = mount(renew => {
  // 특정 속성만 구독
  const sharedStore = useSharedStore(renew, (store) => [store.text]);

  return () => <div>{sharedStore.text}</div>;
});
```

**lstore (자동 모드):**
```tsx
import { lmount } from 'lithent';
import { lstore } from 'lithent/helper';

// lstore는 { useStore, watch } 객체를 리턴
const counterStore = lstore({ count: 0 });

const Display = lmount(() => {
  // lmount에서는 useStore() 사용
  const counter = counterStore.useStore();
  return () => <div>Count: {counter.count}</div>;
});

const Controls = lmount(() => {
  const counter = counterStore.useStore();
  return () => <button onClick={() => counter.count++}>+</button>;
});
```

lstore는 `{ useStore, watch }` 형태로 리턴됩니다. `useStore`는 lmount에서 자동으로 구독하고, `watch`는 mount에서 renew를 수동으로 전달할 때 사용합니다.

store를 사용하면 prop drilling 없이 여러 컴포넌트에서 상태를 공유할 수 있습니다.

### context / lcontext

`context`는 컴포넌트 트리를 통해 데이터를 전달합니다. store와 달리 각 Provider마다 독립적인 값을 가질 수 있습니다.

**context 생성:**
```tsx
import { mount } from 'lithent';
import { createContext } from 'lithent/helper';

// 1. Context 타입 정의 및 생성
type ThemeContext = {
  theme: string;
};

const themeContext = createContext<ThemeContext>();
const { Provider, contextState, useContext } = themeContext;

// 2. Provider에서 contextState로 state 생성
const App = mount(renew => {
  // contextState로 state 생성 (renew 없이 권장)
  const themeState = contextState('light');

  return () => (
    <Provider theme={themeState}>
      <Button />
      <ThemeToggle />
    </Provider>
  );
});

// 3. Consumer에서 useContext로 접근
const Button = mount(renew => {
  const ctx = useContext(themeContext, renew);

  return () => (
    <button style={{ background: ctx.theme.value === 'dark' ? '#333' : '#fff' }}>
      Click me
    </button>
  );
});

const ThemeToggle = mount(renew => {
  const ctx = useContext(themeContext, renew);

  const toggleTheme = () => {
    ctx.theme.value = ctx.theme.value === 'light' ? 'dark' : 'light';
  };

  return () => <button onClick={toggleTheme}>Toggle Theme</button>;
});
```

**선택적 구독:**
```tsx
// 특정 키만 구독
const ctx = useContext(themeContext, renew, ['theme']);
```

**lcontext (자동 모드):**
lcontext는 lmount 컴포넌트를 위한 context입니다. renew 관리가 자동화되어 더 간편합니다.

### computed

`computed`는 복잡한 계산식을 미리 처리하여 템플릿을 깔끔하게 유지합니다.

```tsx
import { mount } from 'lithent';
import { state, computed } from 'lithent/helper';

const Component = mount(renew => {
  const count = state(0, renew);

  const doubleCount = computed(() => count.value * 2);
  const quadCount = computed(() => doubleCount.value * 2);

  return () => (
    <div>
      <p>count: {count.value}</p>
      <p>double: {doubleCount.value}</p>
      <p>quad: {quadCount.value}</p>
      <button onClick={() => count.value++}>+</button>
    </div>
  );
});
```

computed 값은 getter로만 접근 가능하며, 업데이터가 실행될 때마다 재계산됩니다.

### effect

`effect`는 `mountCallback`과 `updateCallback`을 결합한 Helper로, 부수 효과를 관리합니다.

```tsx
import { mount } from 'lithent';
import { state, effect } from 'lithent/helper';

const Timer = mount(renew => {
  const seconds = state(0, renew);
  let intervalId: number;

  effect(
    // forward: 부수 효과 실행
    () => {
      intervalId = setInterval(() => {
        seconds.value += 1;
      }, 1000);
    },
    // backward: 클린업 (선택적)
    () => {
      clearInterval(intervalId);
    },
    // dependencies: 의존성 배열을 반환하는 함수 (선택적)
    () => [] // 빈 배열 = 마운트 시에만 실행
  );

  return () => <div>Seconds: {seconds.value}</div>;
});
```

**인자 구조:**
- **첫 번째 인자 (forward)**: 부수 효과를 실행하는 함수
- **두 번째 인자 (backward)**: 클린업 함수 (선택적, undefined 가능)
- **세 번째 인자 (dependencies)**: 의존성 배열을 반환하는 함수 (선택적, 기본값은 빈 배열)

**의존성 관리:**
```tsx
const count = state(0, renew);

// 빈 배열: 마운트 시에만 실행
effect(() => console.log('Once'), undefined, () => []);

// 특정 값 변경 시 실행
effect(() => console.log('Count changed'), undefined, () => [count.value]);
```

**중요:** 클린업은 forward의 리턴이 아니라 **별도의 두 번째 인자**입니다.

### cacheUpdate

`cacheUpdate`는 특정 값이 변경되지 않으면 리렌더링을 방지합니다.

```tsx
import { mount } from 'lithent';
import { state, cacheUpdate } from 'lithent/helper';

const Component = mount(renew => {
  const count1 = state(0, renew);
  const count2 = state(0, renew);

  return cacheUpdate(
    () => [count1.value], // count1만 감지
    () => (
      <div>
        count1: {count1.value}, count2: {count2.value}
        <button onClick={() => count1.value++}>+count1</button>
        <button onClick={() => count2.value++}>+count2 (no rerender)</button>
      </div>
    )
  );
});
```

`count2`가 변경되어도 UI가 업데이트되지 않아 불필요한 렌더링을 방지할 수 있습니다.

---

## 템플릿 옵션

Lithent는 다양한 템플릿 문법을 지원합니다.

### JSX

Vite와 함께 사용할 때 공식 플러그인으로 JSX를 바로 사용할 수 있습니다.

```bash
npm install -D @lithent/lithent-vite
```

```ts
// vite.config.ts
import { defineConfig } from 'vite';
import lithent from '@lithent/lithent-vite';

export default defineConfig({
  plugins: [lithent()]
});
```

TypeScript 설정:
```json
{
  "compilerOptions": {
    "jsx": "react-jsx",
    "jsxImportSource": "lithent"
  }
}
```

### HTM Tags

`lTag`를 사용하면 빌드 툴 없이 JSX와 유사한 문법을 사용할 수 있습니다.

```html
<script src="https://cdn.jsdelivr.net/npm/lithent/dist/lithent.umd.js"></script>
<script src="https://cdn.jsdelivr.net/npm/lithent/tag/dist/lithentTag.umd.js"></script>

<script>
  const { render, mount, Fragment } = lithent;
  const { lTag } = lithentTag;

  const Component = mount(renew => {
    let count = 0;
    const increase = () => { count++; renew(); };

    return () => lTag`
      <${Fragment}>
        <div>count: ${count}</div>
        <button onClick=${increase}>Increase</button>
      <//>
    `;
  });

  render(lTag`<${Component} />`, document.getElementById('root'));
</script>
```

lTag는 [HTM](https://github.com/developit/htm)을 Lithent의 `h` 함수와 미리 바인딩한 것입니다.

### FTags

`fTags`는 함수 호출 방식으로 가상돔을 정의합니다.

```html
<script src="https://cdn.jsdelivr.net/npm/lithent/dist/lithent.umd.js"></script>
<script src="https://cdn.jsdelivr.net/npm/lithent/ftags/dist/lithentFTags.umd.js"></script>

<script>
  const { render } = lithent;
  const { fTags, fMount, fFragment } = lithentFTags;
  const { div, button, p } = fTags;

  const Counter = fMount(renew => {
    let count = 0;
    const increase = () => { count++; renew(); };

    return () => fFragment(
      p(`count: ${count}`),
      button({ onClick: increase }, 'Increase')
    );
  });

  render(Counter(), document.getElementById('root'));
</script>
```

fTags는 빌드 툴 없이 타입 안전성을 유지할 수 있는 장점이 있습니다.

### Template Strings

`@lithent/lithent-vite` 플러그인의 옵션을 통해 JSX에 Vue와 유사한 디렉티브 문법을 추가로 사용할 수 있습니다. JSX와 완전히 동일하게 사용하되, `l-if`, `l-else`, `l-for` 같은 추가 지시어를 활용할 수 있습니다.

**⚠️ 주의: 이 기능은 아직 실험적인 개발 단계입니다.**

```bash
npm install -D @lithent/lithent-vite
```

```ts
// vite.config.ts
import { defineConfig } from 'vite';
import lithent from '@lithent/lithent-vite';

export default defineConfig({
  plugins: [
    lithent({
      template: 'string' // Template Strings 모드 활성화
    })
  ]
});
```

```tsx
import { mount } from 'lithent';

const Component = mount(renew => {
  let count = 0;
  const increase = () => { count++; renew(); };

  return () => (
    <div>
      <p l-if={count > 0}>Count is positive: {count}</p>
      <p l-else>Count is zero or negative</p>
      <button l-on:click={increase}>Increase</button>
    </div>
  );
});
```

지원 디렉티브: `l-if`, `l-else`, `l-for`, `l-on:*`, `l-bind:*` 등

---

## SSR

Lithent는 서버 사이드 렌더링과 하이드레이션을 지원합니다.

### renderToString

서버에서 HTML 문자열을 생성합니다.

```tsx
import { renderToString } from 'lithent/ssr';
import { App } from './App';

// Express 예제
app.get('/', (req, res) => {
  const html = renderToString(<App />);

  res.send(`
    <!DOCTYPE html>
    <html>
      <body>
        <div id="root">${html}</div>
        <script src="/client.js"></script>
      </body>
    </html>
  `);
});
```

### hydration

클라이언트에서 서버 렌더링된 HTML에 이벤트를 연결합니다.

```tsx
import { hydration } from 'lithent/ssr';
import { App } from './App';

// 클라이언트
hydration(<App />, document.getElementById('root'));
```

hydration은 기존 DOM을 재사용하여 초기 로드 성능을 최적화합니다.

### renderWithHydration

서버/클라이언트 모두에서 사용 가능한 유니버설 렌더 함수입니다.

```tsx
import { renderWithHydration } from 'lithent/ssr';

// 서버에서는 renderToString으로 동작
// 클라이언트에서는 hydration으로 동작
const result = renderWithHydration(<App />, containerElement);
```

---

## 마치며

Lithent는 **작은 크기**, **명확한 제어**, **선택적 확장**이라는 세 가지 핵심 원칙을 바탕으로 설계되었습니다.

- 4KB 코어로 완전한 UI 구축 가능
- 클로저 기반의 예측 가능한 상태 관리
- 필요한 Helper만 선택적으로 사용
- JSX, HTM, FTags 등 다양한 템플릿 옵션
- SSR과 하이드레이션 지원

더 자세한 내용은 [공식 문서](https://superlucky84.github.io/lithent/)를 참고하세요.

**프로젝트 링크:**
- [GitHub](https://github.com/superlucky84/lithent)
- [npm](https://www.npmjs.com/package/lithent)
- [Homepage](https://superlucky84.github.io/lithent/)

