export const preload = async ({ id, origin }) => {
  const { views, date } = await fetch(`${origin}/api/views/${id}`).then(
    response => response.json()
  );
  return {
    layout: {
      views,
      date,
      title: '나만의 커스텀 React 제작기',
      description:
        'React를 걱정 없이 사용할 정도로 이해하기 위해서 직접 리액트처럼 동작하는 코드를 구현해 보고 싶은 욕망이 들었고, 틈틈이 공부하며 만들다 보니 나만의 짝퉁 React를 만들게 되었다.',
      openGraph: {
        title: '나만의 커스텀 React 제작기',
        description:
          'React를 걱정 없이 사용할 정도로 이해하기 위해서 직접 리액트처럼 동작하는 코드를 구현해 보고 싶은 욕망이 들었고, 틈틈이 공부하며 만들다 보니 나만의 짝퉁 React를 만들게 되었다.',
        images: [{ url: '/assets/test11.webp' }],
      },
    },
  };
};

필자는 회사에서 자바스크립트 프레임워크인 React를 자주 사용한다. React를 사용하면 순수 자바스크립트로 많은 공을 들여 구현하던 코드를 훨씬 간단히 만들 수 있다. 마법처럼 느껴질 정도다.

마법 같은 React가 편리하지만 가끔 마음 한편에선 공포가 느껴지곤 했다. React가 마법처럼 느껴진다는 건 React가 동작하는 원리를 충분히 파악하고 있지 못하다는 것이고, 문제가 생겼을 때 스스로 해결하기 어렵다는 걸 알기 때문이다.

단편적인 궁금점을 기술 블로그나 여러 문서를 통해 공부해 보기도 했지만, 이런 노력에도 불구하고 리액트가 계속 마법(=공포)으로 느껴지는 이유는 프레임웍을 만족할 정도로 파악하지 못했기 때문이다.

React를 걱정 없이 사용할 정도로 이해하기 위해서 직접 리액트처럼 동작하는 코드를 구현해 보고 싶은 욕망이 들었고, 틈틈이 공부하며 만들다 보니 나만의 짝퉁 React를 만들게 되었다.

다 만들고 보니 기쁜 마음이 들었다. 공부한 내용을 공유하여 기쁨을 나눠 보고자 한다.


## 템플릿 문법을 위한 트랜스파일러 구현

필자는 jsx처럼 html태그 형식의 표현을 함수 호출 형태로 변경하는 트랜스파일러를 구현해보았다. react를 공부하기 위한 구현이므로 문법도 jsx와 유사하게 만들었다.

우선 jsx에 대해 알아보자.

### jsx의 이해

jsx는 javascript를 확장한 문법이다. javascript와 html표현이 섞여있는 특수한 규칙을 갖는 문자열이다.

jsx를 실제로 사용하기 위해서는 태그 형태를 이해하는 javascript 파서를 만들어 babel이나 esbuild 같은 트랜스파일러를 연결해 브라우저에서 실행 가능한 형태로 변경해야 한다.

jsx의 html 태그 부분의 문자열들이 변경된 형태는 함수 호출 형태이다. 함수가 html 계층 구조에 따라 순서대로 실행되는 걸 이용해 가상돔을 만들 수 있다.

javascript 파서를 공부해서 jsx구문 분석을 위한 확장을 직접 만들어 보는 것도 도움이 됐겠지만, 우선순위가 높은 다른 공부 거리가 많기 때문에 이번에는 간단히 태그 형태의 문자열을 파싱 하여 함수 호출 형태의 문자열로 바꾸는 트랜스파일러를 만들어 보았다.

### 템플릿 문자열 파싱하기

우선 다른 템플릿 문법 파서들이 어떻게 구현되어 있는지 `vuejs`나 `svelte`같은 오픈소스의 코드를 찾아보았다(모방은 창조의 어머니다).

오픈소스 코드들 대부분 문자열 커서와 트리 자료구조를 활용하여 구문 분석을 구현한다는 걸 알아내었다. 깊게 코드를 파악하진 못했지만 대강의 구현원리를 알아낸 뒤, 스스로 충분히 구현 가능하겠다는 생각이 들었을 때 무작정 코드를 작성하기 시작했다.

목표는 태그 문자열을 분석하여 함수 형태로 변경하는 것이다. 생각했던 부분까지 단계적 목표를 세워가며 전부 구현하고 나니 4단계 처리를 통해 목표한 결과를 얻게 되었다.

jsx를 공부하기 위한 목적으로 시작했기 때문에 자연스럽게 jsx와 유사한 사용자 인터페이스를 갖도록 만들었다. 다만 jsx는 javascript문법을 확장하여 만들어졌기 때문에 if문이나 반복문 같은 문법은 javascript 문법을 그대로 사용할 수 있는 반면, 필자의 구현은 간단한 문자열 변환을 이용해 만들었기 때문에 if문이나 반복문은 태그 내에 특수한 속성(디렉티브)을 만들어 대체하였다.

아래는 필자의 템플릿 문자열 파싱을 위한 4단계 과정을 간략하게 정리한 내용이다.

### 1단계 — 문자열 분석하여 태그 트리 만들기

1단계 목표는 아래 예시처럼 html 형태의 원본 문자열로부터 태그의 부모 자식 관계를 알 수 있는 트리구조 객체로 변환하는 것이다.

변환된 객체를 살펴보면 `s` 속성은 태그의 이름을 포함한 모든 애트리뷰트 문자열을 가지고 있고 `hasChildren`은 자식 태그를 갖고 있는지의 `boolean`값 `children`은 실제 하위 태그들의 정보이다


#### 원본 문자열

```jsx
'<div class='root'>
  <button onClick={handle}>one{two}three</button>
  <button onClick={handle2}>onetwothree</button>
  <button onClick={handle3}>cc</button>
</div>'
```


```jsx

#### 결과 객체

```javascript
{
  s: "div class="root",
  hasChildren: true,
  children: [
    {s: 'button onClick={handle}', hasChildren: true, children: Array(1) }
    {s: 'button onClick={handle2}', hasChildren: true, children: Array(1) }
    {s: 'button onClick={handle3}', hasChildren: true, children: Array(1) }
  ]
}
```

